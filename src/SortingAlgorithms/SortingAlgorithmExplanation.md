**_Bubble Sort_**

    1) Выбираем первый элемент массива и сравниваем его со следующим
    2) Если элемент больше следующего, меняем их местами
    3) Повторяем шаг [2] для всех последующих индексов
    4) Повторяем шаг [3] n раз сначала массива

**_Insertion sort_**

    1) Выбираем второй элемент i с массива и сравниваем его со всеми предыдущими ему элементами j.
    2) Если элементы j больше элемента i, 
        то смещаем весь массив пока i не будет меньше или равно j и вставляем его в то место
    3) Повторяем цикл n раз

**_Selection sort_**

    1) Выбираем самый маленький элемент из массива j (где j = i + 1) 
        и ставим его в конец отсортированного массива i (изначально i = 0 поэтому ставим при 1 итерации в начало)
    2) Повторяем операцию n раз где

**_Quick sort_**

    1) Выбираем элемент от которого будем отталкиваться pivot
    2) Дальше разбиваем массив на два массива, где первый это все элементы меньше либо равные pivot, 
        а второй все элементы больше pivot
    3) Вызываем рекурсивно функцию для каждого из этих массивов, 
        тем самым разбивая на мелкие части участок который нужно рассортировать

**_Shell sort_**

    1) Выбираем середину массива    
    2) Сравниваем определенное количество элементов с элементами после середины массива
    3) Делим каждый раз сравниваемые элементы на 2.2, 
        при этом увеличивая сдвиг с середины элемента пока цикл не дойдет до конца массива

**_Heap sort_**

    1) Строим полную двоичную кучу в виде массива, 
        где левый дочерний элемент может быть вычислен как 2 I + 1, а правый дочерний элемент — как 2 I + 2
    2) На данном этапе самый большой элемент хранится в корне кучи. 
        Заменяем его на последний элемент кучи, а затем уменьшаем ее размер на 1. 
        Наконец, преобразуем полученное дерево в новую двоичную кучу  с новым корнем.
    3) Повторяем вышеуказанные шаги, пока размер кучи больше 1.
 
**_Merge sort_**

    1) Разделяем массив на левую и правую части относительно середины рекурсивно 
        пока не останется 1 или 2 элемента в массиве как слева так и справа
    2) В обратную сторону сравниваем по 2 элемента между собой заполняя новый массив
